1. HTTP란? HTTP(hypertext transfer protocol)

   - 텍스트 기반의 통신 규약으로, 인터넷에서 데이터를 주고 받을 수 있는 프로토콜이다. 클라이언트와 서버가 요청과 응답을 주고 받습니다.
   - 통신상대를 확인하지 않기 때문에 위장이 가능합니다. 의미 없는 리퀘스트도 받기 때문에 DDos 공격에도 취약합니다.
   - 서버나 클라이언트에서 보낸 정보의 정확성을 증명할 수 없기 때문에 보안에 취약합니다.

2. HTTPS란?

   - HTTP + Secure.
   - HTTPS를 사용하여 전송되는 데이터는 SSL를 통해 보호된다.
   - 통신상대를 확인하는 증명서를 이용합니다
   - HTTP가 통신하는 소켓부분을 SSL로 대체하는 것 뿐입니다.
   - 통신 자체를 암호화 SSL(Secure Socket Layer) or TLS(Transport Layer Security)라는 다른 프로토콜을 조합함으로써 HTTP 의 통신 내용을 암호화할 수 있다.
   - HTTP 는 원래 TCP 와 직접 통신했지만, HTTPS 에서 HTTP 는 SSL 과 통신하고 SSL 이 TCP 와 통신 하게 된다

3. TCP는?

   - transport layer의 프로토콜이다
   - connection oriented + reliable
   - ACK와 시퀀스 넘버를 주고받으며 flow control과 error control을 한다.
   - 신뢰성 과 순차적인 전달

4. UDP는?

   - transport layer의 프로토콜이다
   - connectionless + unreliable.
   - 실시간 프로세스 통신에 사용되며, 간단하고 속도가 빠르다
   - flow control, error control을 하지 않는다.
   - UDP를 사용한 것들에는 DNS가 있다. 어떤 호스트 네임의 IP 주소를 찾을 필요가 있는 프로그램은, DNS 서버로 호스트 네임을 포함한 UDP 패킷을 보낸다. 이 서버는 호스트의 IP 주소를 포함한 UDP 패킷으로 응답한다.

5. 3 Way Handshaking

   - TCP에서 connection을 형성하기 위한 메커니즘
   - 클라이언트가 SYN 세그먼트를 보낸다
   - 서버는 SYN, ACK를 보낸다
   - 클라이언트는 ACK를 보낸다
   - 세 단계를 거치면 통신 준비 완료

6. 방화벽이란?

   - 특정 규칙에 따라 접근하려는 특정 네트워크를 제한하는 시스템. IP, 포트를 사용하여 제한하는 방식 등 다양한 규칙이 있다.

7. 레이어별 address

   - transport layer: port
   - network layer: ip address
   - datalink layer: mac address

8. 우리가 Chrome 을 실행시켜 주소창에 특정 URL 값을 입력시키면 어떤 일이 일어나는가?

   1. url 에 입력된 값을 브라우저 내부에서 결정된 규칙에 따라 그 의미를 조사한다.
   2. 조사된 의미에 따라 HTTP Request 메시지를 만든다.
   3. 만들어진 메시지를 웹 서버로 전송한다.

9. HTTP의 GET과 POST

   - GET 방식은 요청하는 데이터가 HTTP Request Message의 Header 부분의 url 에 담겨서 전송된다.
     때문에 url 상에 ? 뒤에 데이터가 붙어 request 를 보내게 되는 것이다.
     이러한 방식은 url 이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다.
     또 보안이 필요한 데이터에 대해서는 데이터가 그대로 url 에 노출되므로 GET방식은 적절하지 않다
     GET 은 가져오는 것이다. 서버에서 어떤 데이터를 가져와서 보여준다거나 하는 용도이지 서버의 값이나 상태 등을 변경하지 않는다.
   - POST 방식의 request 는 HTTP Message의 Body 부분에 데이터가 담겨서 전송된다.
     데이터 크기가 GET 방식보다 크고 보안면에서 낫다.
     POST 는 서버의 값이나 상태를 변경하기 위해서 또는 추가하기 위해서 사용된다.

10. 서버 메시지 200, 400, 500번대의 의미

- 200번대: 클라이언트가 요청한 작업을 서버가 성공적으로 수행했다는 상태라는 것을 알려주는 코드
  - 200 ok: 요청이 성공. http메소드에 따라 정확한 의미는 나눠짐
  - 201 created: 요청에 성공하여 리소스가 생성
  - 204 No content: 요청에 성공했지만 비어있음
- 300번대: 리다이렉션에 관련된 상태들을 의미한다. 클라이언트가 요청한 리소스가 옮겨졌거나 삭제되어서 다른 url을 통해 접근해야하는 경우.
  - 301 move permanetly:  브라우저는 자신의 대한 요청의 응답으로 301을 받으면 HTTP 헤더에 들어있는 Location 필드를 찾아보고, 해당 필드가 존재할 경우 Location 필드에 담긴 URL로 자동으로 리다이렉션한다.
  - 304 Not Modified: 상태 코드 304는 클라이언트가 요청한 리소스가 이전 요청떄와 비교해보았을 때 전혀 달라진 점이 없다는 것을 의미한다. 즉, 말 그대로 Not Modified, 수정되지 않음이다. 자신이 캐싱해놓았던 리소스를 사용하게되며, 이 과정에서 불필요한 통신 페이로드의 낭비를 줄일 수 있다.
- 400번대: 클라이언트가 서버에게 보낸 요청이 잘못된 경우를 의미한다. 만약 이 상태 코드를 발견한다면 높은 확률로 프론트엔드 개발자가 예외 처리를 제대로 안 했거나 요청에 이상한 값이 묻은 경우
  - 400 bad request: 이 응답은 잘못된 문법으로 인하여 서버가 요청을 이해할 수 없음을 의미합니다.
  - 401 Unauthorized: 인증되지 않은 사용자가 인증이 필요한 리소스를 요청하는 경우에 “너 인증 필요함”이라고 알려주는 상태 코드이다. 보통 로그인이 필요한 API를 비로그인 사용자가 호출했을 때 많이 사용된다.
  - 403 Forbidden: 백엔드 어플리케이션은 현재 리소스를 요청한 사용자가 누구인지 전혀 신경쓰지 않는다. 클라이언트가 현재 자신이 누구인지 밝혔던 밝히지 않았던, 인증이 되었던 안 되었던 간에, 이 리소스를 요청하는 것은 무조건 금지라고 말하고 있는 것이다. 401은 말 그대로 인증되지 않았다는 것을 의미하며, 인증이 되지 않았다는 것은 백엔드 어플리케이션이 현재 요청한 사용자가 누구인지 알 수가 없다는 것을 의미한다. 즉 이때 서버는 클라이언트에게 “너의 신원을 밝혀!”라고 말하고 있는 것이다.
  - 404 Not Found: 서버는 요청받은 리소스를 찾을 수 없습니다. 브라우저에서는 알려지지 않은 URL을 의미합니다. 이것은 API에서 종점은 적절하지만 리소스 자체는 존재하지 않음을 의미할 수도 있습니다.
  - 429 Too Many Requests: 상태 코드 429는 클라이언트가 서버에 너무 요청을 많이 보내는 경우에 발생한다. 너무 많이 보냈다는 것은, 너무 짧은 시간 안에 빠르게 요청을 마구 날려대서 서버가 “워워 진정해”라고 하는 경우일수도 있고, 유료 API를 사용하는 경우에는 현재 금액으로 사용할 수 있는 API 요청 횟수를 초과해서 “돈을 더 내세요”라는 의미로 사용되기도 한다.
- 500번대: 서버에서 뭔가 말썽이 일어난 경우이다.
  - 500 Internal Server Error : 상태 코드 500은 백엔드 어플리케이션 내에서 뭔가 알 수 없는 에러가 발생했다는 의미이다. 대부분 제대로 핸들링되지 않은 에러가 발생한 경우가 많으므로, 에러의 원인을 클라이언트에게 알려주지 않는다.
  - 502 Bad Gateway: 상태 코드 502를 만날 수 있는 가장 흔한 상황은 바로 백엔드 어플리케이션이 죽은 상황이다.
  - 504 Gateway Timeout: 상태 코드 504는 408과 마찬가지로 요청에 대한 타임아웃을 의미한다. 그러나 504 상태 코드는 클라이언트에서 보낸 요청 때문에 타임아웃이 발생하는 것이 아니라 백엔드 아키텍처 내부에서 서버끼리 주고받는 요청에서 발생한다.
- [출처](https://evan-moon.github.io/2020/03/15/about-http-status-code/#500%EB%B2%88%EB%8C%80)
